using Microsoft.EntityFrameworkCore;
using CopilotApiProject.Data;
using CopilotApiProject.Models;

namespace CopilotApiProject.Repositories;

/// <summary>
/// Entity Framework-based implementation of IUserRepository that uses UserManagementContext for data persistence.
/// This implementation provides full CRUD operations with database persistence and supports
/// advanced querying capabilities through Entity Framework Core.
/// Use this implementation when you need persistent data storage with SQL Server or other databases.
/// </summary>
public class UserRepository : IUserRepository
{
    private readonly UserManagementContext _context;

    /// <summary>
    /// Initializes a new instance of UserRepository with the specified database context.
    /// </summary>
    /// <param name="context">The Entity Framework database context for user management operations.</param>
    public UserRepository(UserManagementContext context)
    {
        _context = context;
    }

    /// <summary>
    /// Retrieves all active users from the database, ordered by last name then first name.
    /// Only returns users where IsActive is true (excludes soft-deleted users).
    /// Uses Entity Framework's async methods for optimal performance.
    /// </summary>
    /// <returns>A task that represents the asynchronous operation containing a collection of active users.</returns>
    public async Task<IEnumerable<User>> GetAllUsersAsync()
    {
        return await _context.Users
            .Where(u => u.IsActive)
            .OrderBy(u => u.LastName)
            .ThenBy(u => u.FirstName)
            .ToListAsync();
    }

    /// <summary>
    /// Retrieves a user by their unique identifier from the database.
    /// Uses Entity Framework's FindAsync method for optimized primary key lookup.
    /// Returns the user regardless of their IsActive status for administrative purposes.
    /// </summary>
    /// <param name="id">The unique identifier of the user to retrieve.</param>
    /// <returns>A task that represents the asynchronous operation containing the user if found, null otherwise.</returns>
    public async Task<User?> GetUserByIdAsync(int id)
    {
        return await _context.Users.FindAsync(id);
    }

    /// <summary>
    /// Retrieves a user by their email address from the database.
    /// Performs a case-insensitive search by converting both the search term and database values to lowercase.
    /// Useful for login scenarios and email uniqueness validation.
    /// </summary>
    /// <param name="email">The email address to search for (case-insensitive).</param>
    /// <returns>A task that represents the asynchronous operation containing the user if found, null otherwise.</returns>
    public async Task<User?> GetUserByEmailAsync(string email)
    {
        return await _context.Users
            .FirstOrDefaultAsync(u => u.Email.ToLower() == email.ToLower());
    }

    /// <summary>
    /// Creates a new user in the database with automatic timestamp management.
    /// Sets the CreatedDate to current UTC time and ensures UpdatedDate is null for new records.
    /// The user ID is automatically generated by the database.
    /// </summary>
    /// <param name="user">The user entity to create. ID will be auto-generated.</param>
    /// <returns>A task that represents the asynchronous operation containing the created user with assigned ID.</returns>
    public async Task<User> CreateUserAsync(User user)
    {
        user.CreatedDate = DateTime.UtcNow;
        user.UpdatedDate = null;
        
        _context.Users.Add(user);
        await _context.SaveChangesAsync();
        return user;
    }

    /// <summary>
    /// Updates an existing user in the database with partial update support.
    /// Only updates properties that are not null or empty, allowing for selective field updates.
    /// Automatically sets the UpdatedDate to current UTC time when any changes are made.
    /// Uses Entity Framework's change tracking for efficient database updates.
    /// </summary>
    /// <param name="id">The ID of the user to update.</param>
    /// <param name="user">The user object containing the fields to update. Only non-null/non-empty fields will be updated.</param>
    /// <returns>A task that represents the asynchronous operation containing the updated user if found, null if user doesn't exist.</returns>
    public async Task<User?> UpdateUserAsync(int id, User user)
    {
        var existingUser = await _context.Users.FindAsync(id);
        if (existingUser == null)
            return null;

        // Update only non-null properties for partial update support
        if (!string.IsNullOrEmpty(user.FirstName))
            existingUser.FirstName = user.FirstName;
        
        if (!string.IsNullOrEmpty(user.LastName))
            existingUser.LastName = user.LastName;
        
        if (!string.IsNullOrEmpty(user.Email))
            existingUser.Email = user.Email;
        
        if (!string.IsNullOrEmpty(user.PhoneNumber))
            existingUser.PhoneNumber = user.PhoneNumber;
        
        if (!string.IsNullOrEmpty(user.Department))
            existingUser.Department = user.Department;
        
        if (!string.IsNullOrEmpty(user.Position))
            existingUser.Position = user.Position;
        
        if (!string.IsNullOrEmpty(user.Address))
            existingUser.Address = user.Address;
        
        if (user.Salary.HasValue)
            existingUser.Salary = user.Salary;
        
        if (user.HireDate.HasValue)
            existingUser.HireDate = user.HireDate;

        // Always update the modification timestamp
        existingUser.UpdatedDate = DateTime.UtcNow;

        await _context.SaveChangesAsync();
        return existingUser;
    }

    /// <summary>
    /// Performs a soft delete on a user by setting their IsActive flag to false.
    /// The user record is preserved in the database for audit trail and data integrity purposes.
    /// Updates the UpdatedDate timestamp to track when the deletion occurred.
    /// This approach is preferred over hard deletion to maintain referential integrity.
    /// </summary>
    /// <param name="id">The ID of the user to soft delete.</param>
    /// <returns>A task that represents the asynchronous operation containing true if the user was found and deleted, false if user doesn't exist.</returns>
    public async Task<bool> DeleteUserAsync(int id)
    {
        var user = await _context.Users.FindAsync(id);
        if (user == null)
            return false;

        // Soft delete by setting IsActive to false instead of removing the record
        user.IsActive = false;
        user.UpdatedDate = DateTime.UtcNow;
        
        await _context.SaveChangesAsync();
        return true;
    }

    /// <summary>
    /// Checks if a user with the specified ID exists in the database.
    /// This method checks for existence regardless of the user's IsActive status.
    /// Useful for validation before performing operations that require an existing user.
    /// Uses Entity Framework's AnyAsync for efficient existence checking without loading the entire entity.
    /// </summary>
    /// <param name="id">The user ID to check for existence.</param>
    /// <returns>A task that represents the asynchronous operation containing true if the user exists, false otherwise.</returns>
    public async Task<bool> UserExistsAsync(int id)
    {
        return await _context.Users.AnyAsync(u => u.Id == id);
    }

    /// <summary>
    /// Checks if an email address is already in use by any user in the database.
    /// Performs case-insensitive comparison and supports excluding a specific user ID.
    /// The exclusion feature is useful during user updates to allow keeping the same email.
    /// Essential for enforcing email uniqueness constraints across the system.
    /// </summary>
    /// <param name="email">The email address to check for uniqueness (case-insensitive).</param>
    /// <param name="excludeUserId">Optional user ID to exclude from the check (useful for updates).</param>
    /// <returns>A task that represents the asynchronous operation containing true if the email exists for another user, false if available.</returns>
    public async Task<bool> EmailExistsAsync(string email, int? excludeUserId = null)
    {
        var query = _context.Users.Where(u => u.Email.ToLower() == email.ToLower());
        
        if (excludeUserId.HasValue)
            query = query.Where(u => u.Id != excludeUserId.Value);
        
        return await query.AnyAsync();
    }

    /// <summary>
    /// Retrieves all active users from a specific department, ordered by name.
    /// Performs case-insensitive department matching and only returns active users.
    /// Useful for generating department-specific reports and organizational charts.
    /// Results are sorted by last name then first name for consistent ordering.
    /// </summary>
    /// <param name="department">The department name to filter by (case-insensitive).</param>
    /// <returns>A task that represents the asynchronous operation containing a collection of active users in the specified department.</returns>
    public async Task<IEnumerable<User>> GetUsersByDepartmentAsync(string department)
    {
        return await _context.Users
            .Where(u => u.IsActive && u.Department.ToLower() == department.ToLower())
            .OrderBy(u => u.LastName)
            .ThenBy(u => u.FirstName)
            .ToListAsync();
    }

    /// <summary>
    /// Searches for active users based on a search term that matches multiple fields.
    /// Performs case-sensitive partial matching across FirstName, LastName, Email, Department, and Position fields.
    /// Only returns active users (IsActive = true) to exclude soft-deleted records from search results.
    /// Results are ordered by last name then first name for consistent presentation.
    /// Note: Uses SQL Server's Contains method which performs case-sensitive searches.
    /// </summary>
    /// <param name="searchTerm">The term to search for across multiple user fields.</param>
    /// <returns>A task that represents the asynchronous operation containing a collection of users matching the search criteria.</returns>
    public async Task<IEnumerable<User>> SearchUsersAsync(string searchTerm)
    {
        return await _context.Users
            .Where(u => u.IsActive && 
                (u.FirstName.Contains(searchTerm) || 
                 u.LastName.Contains(searchTerm) || 
                 u.Email.Contains(searchTerm) ||
                 u.Department.Contains(searchTerm) ||
                 u.Position.Contains(searchTerm)))
            .OrderBy(u => u.LastName)
            .ThenBy(u => u.FirstName)
            .ToListAsync();
    }
}